{ config, pkgs, lib, ... }:

with lib;
let cfg = config.services.overleaf;
in {
  imports = [
    ./containers/sharelatex.nix
    ./containers/mongo.nix
    ./containers/redis.nix
  ];

  options.services.overleaf = {
    enable = mkEnableOption "Overleaf comunity edition service";

    user = mkOption {
      type = str;
      default = "overleaf";
      description = "User account under which Overleaf runs.";
    };

    group = mkOption {
      type = str;
      default = "overleaf";
      description = "Group under which Overleaf runs.";
    };

    dataDir = mkOption {
      type = path;
      default = "/var/lib/overleaf";
      description = ''
        Base data directory.
      '';
    };

    configDir = mkOption {
      type = path;
      default = "${cfg.dataDir}/config";
      defaultText = "\${cfg.dataDir}/config";
      description = ''
        Directory containing the server configuration files.
      '';
    };

    redisDir = mkOption {
      type = path;
      default = "${cfg.dataDir}/redis";
      defaultText = "\${cfg.dataDir}/redis";
      description = ''
        Directory containing redis.
      '';
    };

    mongoDir = mkOption {
      type = path;
      default = "${cfg.dataDir}/mongo";
      defaultText = "\${cfg.dataDir}/mongo";
      description = ''
        Directory containing MongoDb.
      '';
    };

    openFirewall = mkOption {
      type = bool;
      default = false;
      description = ''
        Open the default ports in the firewall for the media server.
      '';
    };
  };

  config = mkIf cfg.enable {
    systemd = {
      tmpfiles.settings.overleafDirs = {
        "${cfg.dataDir}"."d" = {
          mode = "700";
          inherit (cfg) user group;
        };
      };
    };

    virtualisation = {
      podman = {
        enable = true;
        autoPrune.enable = true;
        dockerCompat = true;
      };
    };

    # Enable container name DNS for all Podman networks.
    networking.firewall = {
      interfaces = let
        matchAll =
          if !config.networking.nftables.enable then "podman+" else "podman*";
      in { "${matchAll}".allowedUDPPorts = [ 53 ]; };

      allowedTCPPorts = lib.mkIf cfg.openFirewall [ 80 ];
    };

    virtualisation.oci-containers.backend = "podman";

    # Networks
    systemd.services."podman-network-overleaf_default" = {
      path = [ pkgs.podman ];
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        ExecStop = "podman network rm -f overleaf_default";
      };
      script = ''
        podman network inspect overleaf_default || podman network create overleaf_default
      '';
      partOf = [ "podman-compose-overleaf-root.target" ];
      wantedBy = [ "podman-compose-overleaf-root.target" ];
    };

    # Root service
    # When started, this will automatically create all resources and start
    # the containers. When stopped, this will teardown all resources.
    systemd.targets."podman-compose-overleaf-root" = {
      unitConfig = { Description = "Root target generated by compose2nix."; };
      wantedBy = [ "multi-user.target" ];
    };
  };
}
